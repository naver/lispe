;Date: 2022/08/30 14:28:20
;Description: Parser for basic description
;Generated with LispE Transpiler

(defun compare (tokens value i v keep)
   (check 
      (and
         (< (car i) (size tokens))      
         (eq (@ tokens (car i)) value)
      )
      (+= i 1)
      (if keep
         (push v value)
      )
      (return true)
   )
)

(defun C_Word (tokens i v)
   (check (< (car i) (size tokens))
      (setq w (@ tokens (car i)))
      (check 
         (and
            (rgx "%a{%a%d_}*" w)
            (nokeywords w)
         )
         (+= i 1)
         (push v w)
         (return true)
      )
   )
)

(defun C_astring(tokens i v)
   (check (< (car i) (size tokens))
      (setq m (@ tokens (car i)))
      (check (and
            (eq (@ m 0) "\"")
            (eq (@ m -1) "\"")
         )
         (+= i 1)
         (push v (list 'string (@@ m 1 -1)))
         (return true)
      )
   )
)


(defun C_anumber (tokens i v)
   (check (< (car i) (size tokens))
      (setq w (@ tokens (car i)))
      (check (rgx "({-%+})%d+(.%d+({eE}(-)%d+))" w)
         (+= i 1)
         (push v (list 'anumber (float w)))
         (return true)
      )
   )
)

;Â°analyse := [function^expressions]+ (entry point)
(defun C_analyse (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (P_analyse_0 tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (cons 'analyse v0)
      )
   )
)

(defun P_analyse_0 (tokens i1 vp)
   (setq v ())
   (setq v1 ())
   (check (or
         (C_function tokens i1 v1)
         (C_expressions tokens i1 v1)
      )
      (push v v1)
      (setq v1 ())
      (while (or
            (C_function tokens i1 v1)
            (C_expressions tokens i1 v1)
         )
         (nconc v v1)
         (setq v1 ())
      )
   )
   (if v
      (nconc vp v)
   )
)

;operator := [%< %<]^[%> %>]^[%^ %^]^[%* %*]^%&^%|^%+^%-^%*^%/^%%^%^
(defun C_operator (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (or
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens "<" i1 v1 true)
               (compare tokens "<" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens ">" i1 v1 true)
               (compare tokens ">" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens "^" i1 v1 true)
               (compare tokens "^" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens "*" i1 v1 true)
               (compare tokens "*" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (compare tokens "&" i0 v0 true)
            (compare tokens "|" i0 v0 true)
            (compare tokens "+" i0 v0 true)
            (compare tokens "-" i0 v0 true)
            (compare tokens "*" i0 v0 true)
            (compare tokens "/" i0 v0 true)
            (compare tokens "%" i0 v0 true)
            (compare tokens "^" i0 v0 true)
         )
         (push v (cons 'operator v0))
      )
   )
)

;orand := $or^$and^$xor
(defun C_orand (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (or
            (compare tokens "or" i0 v0 true)
            (compare tokens "and" i0 v0 true)
            (compare tokens "xor" i0 v0 true)
         )
         (push v (cons 'orand v0))
      )
   )
)

;comparator := [%< %>]^[%< %=]^[%= %=]^[%> %=]^%<^%>
(defun C_comparator (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (or
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens "<" i1 v1 true)
               (compare tokens ">" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens "<" i1 v1 true)
               (compare tokens "=" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens "=" i1 v1 true)
               (compare tokens "=" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (and
               (setq i1 (clone i0))
               (setq v1 ())
               (compare tokens ">" i1 v1 true)
               (compare tokens "=" i1 v1 true)
               (set@ i0 0 (car i1))
               (setq v0 v1)
            )
            (compare tokens "<" i0 v0 true)
            (compare tokens ">" i0 v0 true)
         )
         (push v (cons 'comparator v0))
      )
   )
)

;comparison := computing comparator computing [orand comparison]*
(defun C_comparison (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_computing tokens i1 v1)
            (C_comparator tokens i1 v1)
            (C_computing tokens i1 v1)
            (S_comparison_0 tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'comparison v0))
      )
   )
)

(defun S_comparison_0 (tokens i1 vp)
   (setq v ())
   (while (and
         (setq i2 (clone i1))
         (setq v2 ())
         (C_orand tokens i2 v2)
         (C_comparison tokens i2 v2)
         (set@ i1 0 (car i2))
         (setq v1 v2)
      )
      (nconc v v1)
   )
   (check v
      (nconc vp v)
   )
   true)

;!minus := %- anumber
(defun C_minus (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "-" i1 v1 nil)
            (C_anumber tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'minus v0))
      )
   )
)

;!setdimvariable :=  Word %[ computing %]
(defun C_setdimvariable (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (compare tokens "[" i1 v1 nil)
            (C_computing tokens i1 v1)
            (compare tokens "]" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'setdimvariable v0))
      )
   )
)

;!setdimvariablestring :=  Word %$ %[ computing %]
(defun C_setdimvariablestring (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (compare tokens "$" i1 v1 nil)
            (compare tokens "[" i1 v1 nil)
            (C_computing tokens i1 v1)
            (compare tokens "]" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push
            v
            (cons 'setdimvariablestring v0)
         )
      )
   )
)

;!dimvariable := Word %[ computing %]
(defun C_dimvariable (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (compare tokens "[" i1 v1 nil)
            (C_computing tokens i1 v1)
            (compare tokens "]" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'dimvariable v0))
      )
   )
)

;!dimvariablestring := Word %$ %[ computing %]
(defun C_dimvariablestring (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (compare tokens "$" i1 v1 nil)
            (compare tokens "[" i1 v1 nil)
            (C_computing tokens i1 v1)
            (compare tokens "]" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'dimvariablestring v0))
      )
   )
)

;!stringvariable := Word %$
(defun C_stringvariable (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (compare tokens "$" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'stringvariable v0))
      )
   )
)

;variable := Word
(defun C_variable (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'variable v0))
      )
   )
)

;!variables := [stringvariable^variable] [%, [stringvariable^variable]]*
(defun C_variables (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (or
               (C_stringvariable tokens i1 v1)
               (C_variable tokens i1 v1)
            )
            (S_variables_0 tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'variables v0))
      )
   )
)

(defun S_variables_0 (tokens i1 vp)
   (setq v ())
   (while (and
         (setq i2 (clone i1))
         (setq v2 ())
         (compare tokens "," i2 v2 nil)
         (or
            (C_stringvariable tokens i2 v2)
            (C_variable tokens i2 v2)
         )
         (set@ i1 0 (car i2))
         (setq v1 v2)
      )
      (nconc v v1)
   )
   (check v
      (nconc vp v)
   )
   true)

;!call := Word %( [computing [%, computing]*]? %)
(defun C_call (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (compare tokens "(" i1 v1 nil)
            (O_call_1 tokens i1 v1)
            (compare tokens ")" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'call v0))
      )
   )
)

(defun S_call_0 (tokens i2 vp)
   (setq v ())
   (while (and
         (setq i3 (clone i2))
         (setq v3 ())
         (compare tokens "," i3 v3 nil)
         (C_computing tokens i3 v3)
         (set@ i2 0 (car i3))
         (setq v2 v3)
      )
      (nconc v v2)
   )
   (check v
      (nconc vp v)
   )
   true)

(defun O_call_1 (tokens i1 vp)
   (setq v1 ())
   (check (and
         (setq i2 (clone i1))
         (setq v2 ())
         (C_computing tokens i2 v2)
         (S_call_0 tokens i2 v2)
         (set@ i1 0 (car i2))
         (setq v1 v2)
      )
      (nconc vp v1)
   )
   true)

;!method := [dimvariablestring^dimvariable^stringvariable^variable] %. Word %( [computing [%, computing]*]? %)
(defun C_method (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (or
               (C_dimvariablestring tokens i1 v1)
               (C_dimvariable tokens i1 v1)
               (C_stringvariable tokens i1 v1)
               (C_variable tokens i1 v1)
            )
            (compare tokens "." i1 v1 nil)
            (C_Word tokens i1 v1)
            (compare tokens "(" i1 v1 nil)
            (O_method_1 tokens i1 v1)
            (compare tokens ")" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'method v0))
      )
   )
)

(defun S_method_0 (tokens i2 vp)
   (setq v ())
   (while (and
         (setq i3 (clone i2))
         (setq v3 ())
         (compare tokens "," i3 v3 nil)
         (C_computing tokens i3 v3)
         (set@ i2 0 (car i3))
         (setq v2 v3)
      )
      (nconc v v2)
   )
   (check v
      (nconc vp v)
   )
   true)

(defun O_method_1 (tokens i1 vp)
   (setq v1 ())
   (check (and
         (setq i2 (clone i1))
         (setq v2 ())
         (C_computing tokens i2 v2)
         (S_method_0 tokens i2 v2)
         (set@ i1 0 (car i2))
         (setq v1 v2)
      )
      (nconc vp v1)
   )
   true)

;!assignment := [setdimvariablestring^setdimvariable^stringvariable^variable] %= computing
(defun C_assignment (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (or
               (C_setdimvariablestring tokens i1 v1)
               (C_setdimvariable tokens i1 v1)
               (C_stringvariable tokens i1 v1)
               (C_variable tokens i1 v1)
            )
            (compare tokens "=" i1 v1 nil)
            (C_computing tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'assignment v0))
      )
   )
)

;!dim :=  $DIM Word %[ computing %]
(defun C_dim (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "DIM" i1 v1 nil)
            (C_Word tokens i1 v1)
            (compare tokens "[" i1 v1 nil)
            (C_computing tokens i1 v1)
            (compare tokens "]" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'dim v0))
      )
   )
)

;!dimstring :=  $DIM Word %$ %[ computing %]
(defun C_dimstring (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "DIM" i1 v1 nil)
            (C_Word tokens i1 v1)
            (compare tokens "$" i1 v1 nil)
            (compare tokens "[" i1 v1 nil)
            (C_computing tokens i1 v1)
            (compare tokens "]" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'dimstring v0))
      )
   )
)

;!parenthetic := %( computing %)
(defun C_parenthetic (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "(" i1 v1 nil)
            (C_computing tokens i1 v1)
            (compare tokens ")" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'parenthetic v0))
      )
   )
)

;^callitem := method^call^parenthetic^astring^minus^anumber^dimvariablestring^dimvariable^stringvariable^variable
(defun C_callitem (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (or
            (C_method tokens i0 v0)
            (C_call tokens i0 v0)
            (C_parenthetic tokens i0 v0)
            (C_astring tokens i0 v0)
            (C_minus tokens i0 v0)
            (C_anumber tokens i0 v0)
            (C_dimvariablestring tokens i0 v0)
            (C_dimvariable tokens i0 v0)
            (C_stringvariable tokens i0 v0)
            (C_variable tokens i0 v0)
         )
         (nconc v v0)
      )
   )
)

;&computing := callitem  [operator callitem]*
(defun C_computing (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_callitem tokens i1 v1)
            (S_computing_0 tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (if (eq (size v0) 1)
            (nconc v v0)
            (push v (cons 'computing v0))
         )
      )
   )
)

(defun S_computing_0 (tokens i1 vp)
   (setq v ())
   (while (and
         (setq i2 (clone i1))
         (setq v2 ())
         (C_operator tokens i2 v2)
         (C_callitem tokens i2 v2)
         (set@ i1 0 (car i2))
         (setq v1 v2)
      )
      (nconc v v1)
   )
   (check v
      (nconc vp v)
   )
   true)

;!multiop := Word computing [%, computing]*
(defun C_multiop (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (C_Word tokens i1 v1)
            (C_computing tokens i1 v1)
            (S_multiop_0 tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'multiop v0))
      )
   )
)

(defun S_multiop_0 (tokens i1 vp)
   (setq v ())
   (while (and
         (setq i2 (clone i1))
         (setq v2 ())
         (compare tokens "," i2 v2 nil)
         (C_computing tokens i2 v2)
         (set@ i1 0 (car i2))
         (setq v1 v2)
      )
      (nconc v v1)
   )
   (check v
      (nconc vp v)
   )
   true)

;^expressions := method^call^dimstring^dim^assignment^forin^for^if^while^multiop^computing
(defun C_expressions (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (or
            (C_method tokens i0 v0)
            (C_call tokens i0 v0)
            (C_dimstring tokens i0 v0)
            (C_dim tokens i0 v0)
            (C_assignment tokens i0 v0)
            (C_forin tokens i0 v0)
            (C_for tokens i0 v0)
            (C_if tokens i0 v0)
            (C_while tokens i0 v0)
            (C_multiop tokens i0 v0)
            (C_computing tokens i0 v0)
         )
         (nconc v v0)
      )
   )
)

;!then := $Then expressions+
(defun C_then (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "Then" i1 v1 nil)
            (P_then_0 tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'then v0))
      )
   )
)

(defun P_then_0 (tokens i1 vp)
   (setq v ())
   (setq v1 ())
   (check (C_expressions tokens i1 v1)
      (push v v1)
      (setq v1 ())
      (while (C_expressions tokens i1 v1)
         (nconc v v1)
         (setq v1 ())
      )
   )
   (if v
      (nconc vp v)
   )
)

;!else := $Else expressions+
(defun C_else (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "Else" i1 v1 nil)
            (P_else_0 tokens i1 v1)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'else v0))
      )
   )
)

(defun P_else_0 (tokens i1 vp)
   (setq v ())
   (setq v1 ())
   (check (C_expressions tokens i1 v1)
      (push v v1)
      (setq v1 ())
      (while (C_expressions tokens i1 v1)
         (nconc v v1)
         (setq v1 ())
      )
   )
   (if v
      (nconc vp v)
   )
)

;!function := $Function Word %( variables? %) expressions+ $EndFunction
(defun C_function (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "Function" i1 v1 nil)
            (C_Word tokens i1 v1)
            (compare tokens "(" i1 v1 nil)
            (O_function_0 tokens i1 v1)
            (compare tokens ")" i1 v1 nil)
            (P_function_1 tokens i1 v1)
            (
               compare
               tokens
               "EndFunction"
               i1
               v1
               nil
            )
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'function v0))
      )
   )
)

(defun O_function_0 (tokens i1 vp)
   (setq v1 ())
   (check (C_variables tokens i1 v1)
      (nconc vp v1)
   )
   true)

(defun P_function_1 (tokens i1 vp)
   (setq v ())
   (setq v1 ())
   (check (C_expressions tokens i1 v1)
      (push v v1)
      (setq v1 ())
      (while (C_expressions tokens i1 v1)
         (nconc v v1)
         (setq v1 ())
      )
   )
   (if v
      (nconc vp v)
   )
)

;!if := $If comparison then else? $EndIf
(defun C_if (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "If" i1 v1 nil)
            (C_comparison tokens i1 v1)
            (C_then tokens i1 v1)
            (O_if_0 tokens i1 v1)
            (compare tokens "EndIf" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'if v0))
      )
   )
)

(defun O_if_0 (tokens i1 vp)
   (setq v1 ())
   (check (C_else tokens i1 v1)
      (nconc vp v1)
   )
   true)

;!while := $While comparison expressions+ $EndWhile
(defun C_while (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "While" i1 v1 nil)
            (C_comparison tokens i1 v1)
            (P_while_0 tokens i1 v1)
            (compare tokens "EndWhile" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'while v0))
      )
   )
)

(defun P_while_0 (tokens i1 vp)
   (setq v ())
   (setq v1 ())
   (check (C_expressions tokens i1 v1)
      (push v v1)
      (setq v1 ())
      (while (C_expressions tokens i1 v1)
         (nconc v v1)
         (setq v1 ())
      )
   )
   (if v
      (nconc vp v)
   )
)

;!forin := $For [stringvariable^variable] $in callitem expressions+ $EndFor
(defun C_forin (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "For" i1 v1 nil)
            (or
               (C_stringvariable tokens i1 v1)
               (C_variable tokens i1 v1)
            )
            (compare tokens "in" i1 v1 nil)
            (C_callitem tokens i1 v1)
            (P_forin_0 tokens i1 v1)
            (compare tokens "EndFor" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'forin v0))
      )
   )
)

(defun P_forin_0 (tokens i1 vp)
   (setq v ())
   (setq v1 ())
   (check (C_expressions tokens i1 v1)
      (push v v1)
      (setq v1 ())
      (while (C_expressions tokens i1 v1)
         (nconc v v1)
         (setq v1 ())
      )
   )
   (if v
      (nconc vp v)
   )
)

;!for := $For assignment %, comparison %, assignment expressions+ $EndFor
(defun C_for (tokens i0 v)
   (check (< (car i0) (size tokens))
      (setq v0 ())
      (if (and
            (setq i1 (clone i0))
            (setq v1 ())
            (compare tokens "For" i1 v1 nil)
            (C_assignment tokens i1 v1)
            (compare tokens "," i1 v1 nil)
            (C_comparison tokens i1 v1)
            (compare tokens "," i1 v1 nil)
            (C_assignment tokens i1 v1)
            (P_for_0 tokens i1 v1)
            (compare tokens "EndFor" i1 v1 nil)
            (set@ i0 0 (car i1))
            (setq v0 v1)
         )
         (push v (cons 'for v0))
      )
   )
)

(defun P_for_0 (tokens i1 vp)
   (setq v ())
   (setq v1 ())
   (check (C_expressions tokens i1 v1)
      (push v v1)
      (setq v1 ())
      (while (C_expressions tokens i1 v1)
         (nconc v v1)
         (setq v1 ())
      )
   )
   (if v
      (nconc vp v)
   )
)


(defun nokeywords(w)
      (not (in  '("or" "and" "xor" "DIM" "Then" "Else" "Function" "EndFunction" "If" "EndIf" "While" "EndWhile" "For" "in" "EndFor") w))
)
   
(setq parser_tok (tokenizer_rules))

(defun retire (rg base)
    (loop i (range 0 (size rg) 1)
       (setq x (@ rg i))
       (check (in x base)
          (pop rg i)
          (break)
      )
   )
)

(setq rg (get_tokenizer_rules parser_tok))

(set@ rg 0 " +=#")
(set@ rg 1 "\t+=#")
(set@ rg 2 "\n+=#")

(retire rg "===0")
(retire rg "<==0")
(retire rg ">==0")
(retire rg "<>=0")

(set_tokenizer_rules parser_tok rg)

(defun basic_abstract_tree (code)
   (setq tokens (tokenize_rules parser_tok code))
   (setq i '(0))
   (setq res (C_analyse tokens i ()))
   (if (< (car i) (size tokens))
      (cons "Error from: " (@@ tokens (car i) (+ 20 (car i))))
      res
   )
)

