# A WebAssembly implementation of LispE

Now you can enrich your JavaScript programs with Lisp. It becomes possible to execute statements such as: `(geometric_distribution 20 0.3)` directly in your JS code and get an _Int32Array_ containing the result of this function.

## What is WebAssembly?

Although JavaScript is now the default language for the Web, it has some limitations, despite significant progress, that make it unusable for some applications such as games or machine learning. The W3C has therefore proposed a new type of code: _WebAssembly_ to overcome these problems. WebAssembly is a binary format, a _bytecode_ that today's browsers can compile and execute. It works as an extension of JavaScript and can approach the performance of native applications, although according to some [studies](https://www.arxiv-vanity.com/papers/1901.09056/), performance is generally 10% to 60% slower than the corresponding C++ program. Above all, this _bytecode_ has now become a compilation target for the most common programming languages such as C++ or Java. Thus, taking an existing C++ code and compiling it into WebAssembly has become quite simple.


### Emscripten: C++ to WASM (WebAssembly)

There are several solutions for compiling to WebAssembly today, and one of the best known is [Emscripten](https://developer.mozilla.org/en-US/docs/WebAssembly/C_to_wasm). Emscripten is based on the LLVM compiler, but offers as a result not only a WASM (WebAssembly) library, but also HTML and JS files to use it.

This is the tool we used to transform LispE into a WebAssembly library. Note that we took inspiration from [_Pragmatic compiling of C++ to WebAssembly. A Guide._](https://medium.com/@tdeniffel/pragmatic-compiling-from-c-to-webassembly-a-guide-a496cc5954b8) to start this project.

## Compilation

We had to make very few changes to the code to compile it. At most we removed some aspects such as sockets, but for the rest a quick look will show that the *LISPE_WASM* compiler option is very little present. The fundamental difference is that we use `em++` rather than `clang` to compile.

The result of the compilation with Emscripten consists of a library `lispe.wasm` and two files `lispe.hmtl` and `lispe.js`. We implemented a fourth file `lispe_functions.js` to wrap the exported functions from the WASM library in JavaScript (see [`mainwasm.cxx`](https://github.com/naver/lispe/blob/master/wasm/mainwasm.cxx) and [`lispe_functions.js`](https://github.com/naver/lispe/blob/master/wasm/lispe_functions.js))


### JavaScript API

The `lispe.js` file, which is generated by `emstdk` contains only the minimal code to load the library and initialize it. 

We have added the following JavaScript functions to run the LispE interpreter:

They take a string as input and they differ essentially on the output type:

```Javascript
//See lispe_functions.js
function callEval(code, size_output) //this function evaluates some LispE code and returns a string

function callEvalToFloats(code, size_output_in_floats) //this function returns an array of Floats (Float64Array)
function callEvalToInts(code, size_output_in_ints) //this function returns an array of integers (Int32Array)
function callEvalToStrings(code, size_output_in_bytes) //this function returns an array of strings

function callEvalAsInt(code) //this function returns an integer
function callEvalAsFloat(code) //this function returns a floating number

function callSetqInts(variable, values, nb) //This function creates a variable whose value is a list of nb integers
function callSetqFloats(variable, values, nb) //This function creates a variable whose value is a list of nb floats
function callSetqInt(variable, value) //This function creates a variable whose value is an integer
function callSetqFloat(variable, value) //This function creates a variable whose value is a float
function callSetqString(a_variable, value) //This function creates a variable whose value is a string 

```

We also need to add an additional function to control the operation of the interpreter:

```Javascript
function callResetLispe() //this function resets the LispE interpreter
```

Note that the code and variables created in LispE are _persistent_, hence the need to be able to regenerate the interpreter when needed. Thus, between two calls, the variables keep their value.

### WASM Files

You can find all the necessary code in the [wasm](https://github.com/naver/lispe/blob/master/wasm) directory:

* `lispe.wasm` is the WebAssembly library that allows you to execute the Lisp code.
* `lispe.js` contains the loading and initialization of the WebAssembly library
* `lispe_functions.js` contains the JS wrappers to access the functions exported by lispe.wasm.
* `mainwasm.cxx`contains the C++ code to bridge LispE with WebAssembly
* `index.hmtl` contains an example of the integration of this library into a Web page in the form of a rudimentary interface for experimenting with the language.


### Memory Usage

First of all, let's remember that WebAssembly works in a _sandbox_, so that memory cannot be corrupted or lost when running a program. For this purpose, the available memory must be defined when compiling WebAssembly with _emcc_. We compiled LispE with the default memory size, but the Makefile shows how to increase this memory if needed. By default this memory corresponds to _256x65536_ memory pages or a total of: _16,777,216 bytes_.

It should be noted that this memory is not only the execution space of a WebAssembly program, it is also the exchange area with the functions exported by the library. Therefore, the arguments of WASM functions must necessarily be allocated in this particular memory space.

For this purpose, we provide the following methods:

```JavaScript
function provideIntegers(nb); returns a vector of nb integer values on 32 bits
function provideFloats(nb); returns a vector of nb 64-bit float values
``` 

The use of these methods ensures that the values passed to the WASM functions will be accessible by them.


Translated with www.DeepL.com/Translator (free version)
### JavaScript stack

The last important point to keep in mind is the constraint imposed by JavaScript on the size of the execution stack. Indeed, if your LispE program tries to make one too many recursive calls, it may trigger an error of type: _stack overflow_.

It can be interesting sometimes (see [Tail Call](https://github.com/naver/lispe/wiki/2.4-Catch-a-Tail-Call)) to slightly modify your code to avoid a stack explosion.


## Playground: _index.hmtl_

We have implemented an example of handling this library in the file: `index.html`.

As you can see, it is possible to interact with `lispe.wasm` in a simple and direct way. You can add code, compile it and execute it on the fly. To re-execute code, you just have to position the cursor at the beginning of the line you want to re-execute. 

By default, the `callEval` method takes code and returns a string as result. In many cases this may be sufficient, but it is also possible to return numeric values or lists of numeric values. It is even possible to minimize compilation by initializing variables directly with lists or strings for example (see _callSetq._).


If we take our example above: `(geometric_distribution 20 0.3)`, it is possible to execute it in such a way that it returns a Javascript _array_ or a string:

```Javascript
var result = callEvalToInts("(geometric_distribution 20 0.3)", 1000), which gives: 8,0,4,1,0,2,2,2,4,1
```

while

```Javascript
var result = callEval("(geometric_distribution 20 0.3)", 1000), gives: "(2 1 0 1 1 0 0 11 5 11)"
```

requires us to parse the above string to extract the corresponding table.

### Persistence

Each call to a _callEval_ function keeps all the variables created in memory.
Thus, it is possible to chain the calls without losing the intermediate values:

```Javascript
(async () => {
    await callEval("(setq r 100)", 1000)
    await callEval("(+= r 1000)", 1000)
    await callEval("(println r)",1000)
    await callEval("r", 100)
})();
```

Note two things about the code above:

1. The consecutive calls are _asynchronous_.
1. The last line executed in a code returns the final value of the evaluation, in this case `r` which is 1100

On the other hand, these variables exist only in the memory space of `lispe.wasm`. This ensures the privacy of the processed data since the execution is local and does not pass through any server. The data is kept in the user's local memory and not in that of a remote server.

### The _println_

A word about the _println_ which can be displayed, thanks to the following declaration in `index.html`

We initialize the `Module` with the _print_ key that we associate with the *textarea: display_evaluation*:
 
```HTML
var Module = {
 print: (function () {
 var element = document.getElementById('display_evaluation'); //textarea name 'display_evaluation'
 return function (text) {
   if (arguments.length > 1) 
       text = Array.prototype.slice.call(arguments).join(' ');
   if (element) {
      element.value += text + "\n";
      element.scrollTop = element.scrollHeight; // focus on bottom
  }
 };
})(),

```

From now on, whenever a _println_ is performed in the LispE code, the display will be redirected to the text box: _display_evaluation_.

### How to test it?

If you want to test it locally, all you need to do is go to the directory with the WASM files and launch:

```sh
python -m http.server --directory . 8080
```
If you have installed the _emsdk_ suite, you can also run instead:

```
emrun --port 8080 .
```

Now, all you have to do is go to a browser and use the following address: `http://localhost:8080`.


## Conclusion

WebAssembly today offers JavaScript developers access to modules compiled in other languages such as C++, Rust or C#. Thanks to tools like _emsdk_, switching from C++ to WebAssembly code is relatively simple, although memory management and argument passing need some attention. Thus, we can offer a very interesting extension to JavaScript in the form of a LispE interpreter, which complements JavaScript with a very rich set of instructions, especially for manipulating lists and strings, thanks to a tight integration.

In particular, LispE offers the ability to write remarkably compact *one-liners* : 

* Splitting a string into sub-strings
```Lisp
// Splits a string into sub-strings
(segment "This is the 100 test"); ("This" "is" "the" "100" "test")
```

* Powerful filters based on a regular expression:

```Lisp
(filterlist (λ(x) (rgx_match (rgx "%C%a+") x)) (segment "The lady lives in Paris. She lives in Montmartre")

which gives: ("The" "Paris" "She" "Montmartre")
``` 

The API makes it possible to exploit the language by returning lists or values directly. Thus, a call to the filter example, will return an array of strings:

```JavaScript
lst = callEvalToStrings("(filterlist (λ(x) (rgx_match (rgx "%C%a+") x)) (segment "The lady lives in Paris")), 1000);

// lst is: La,Paris
```

Finally, the local execution of the code ensures the privacy of the user data and makes it easy to perform verifications or calculations in the browser without having to go through a server.

LispE is a very rich language as shown in the [documentation](https://github.com/naver/lispe/wiki/5.-Description-of-Functions,-Operators-and-Libraries) which offers developers other ways to design and implement their code for the Web.
 
 
